# Name: (*command-line-arguments.T3[T any]).fn1
# Synthetic: wrapper
func (t3 *command-line-arguments.T3[T any]) fn1():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn1"}
	t3 = Parameter <*command-line-arguments.T3[T any]> {r}
	t4 = Call <*command-line-arguments.T3[T any]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.T3[T any]> t4
	t6 = Call <()> (command-line-arguments.T3[a]).fn1 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.T3[T any]).fn2
# Synthetic: wrapper
func (t3 *command-line-arguments.T3[T any]) fn2():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn2"}
	t3 = Parameter <*command-line-arguments.T3[T any]> {r}
	t4 = Call <*command-line-arguments.T3[T any]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.T3[T any]> t4
	t6 = Call <()> (command-line-arguments.T3[b]).fn2 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.T3[T any]).fn3
# Synthetic: wrapper
func (t3 *command-line-arguments.T3[T any]) fn3():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn3"}
	t3 = Parameter <*command-line-arguments.T3[T any]> {r}
	t4 = Call <*command-line-arguments.T3[T any]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.T3[T any]> t4
	t6 = Call <()> (command-line-arguments.T3[c]).fn3 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.T4[a]).fn2
# Synthetic: generic
func (t1 command-line-arguments.T4[a]) fn2():
b0: # entry
	t1 = Parameter <command-line-arguments.T4[a]> {r}
	t2 = ChangeType <command-line-arguments.T4[b]> t1
	t3 = Call <()> (command-line-arguments.T4[b]).fn2 a t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.T4[a]).fn3
# Synthetic: generic
func (t1 command-line-arguments.T4[a]) fn3():
b0: # entry
	t1 = Parameter <command-line-arguments.T4[a]> {r}
	t2 = ChangeType <command-line-arguments.T4[c]> t1
	t3 = Call <()> (command-line-arguments.T4[c]).fn3 a t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.T4[a]).fn1
# Synthetic: wrapper
func (t3 *command-line-arguments.T4[a]) fn1(command-line-arguments.T4[a]):
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn1"}
	t3 = Parameter <*command-line-arguments.T4[a]> {r}
	t4 = Parameter <command-line-arguments.T4[a]> {arg1}
	t5 = Call <*command-line-arguments.T4[a]> ir:wrapnilchk t3 t1 t2
	t6 = Load <command-line-arguments.T4[a]> t5
	t7 = Call <()> (command-line-arguments.T4[a]).fn1 t6 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.T4[a]).fn2
# Synthetic: wrapper
func (t3 *command-line-arguments.T4[a]) fn2():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn2"}
	t3 = Parameter <*command-line-arguments.T4[a]> {r}
	t4 = Call <*command-line-arguments.T4[a]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.T4[a]> t4
	t6 = Call <()> (command-line-arguments.T4[a]).fn2 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.T4[a]).fn3
# Synthetic: wrapper
func (t3 *command-line-arguments.T4[a]) fn3():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn3"}
	t3 = Parameter <*command-line-arguments.T4[a]> {r}
	t4 = Call <*command-line-arguments.T4[a]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.T4[a]> t4
	t6 = Call <()> (command-line-arguments.T4[a]).fn3 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.T4[T any]).fn1
# Synthetic: wrapper
func (t3 *command-line-arguments.T4[T any]) fn1(command-line-arguments.T4[a]):
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn1"}
	t3 = Parameter <*command-line-arguments.T4[T any]> {r}
	t4 = Parameter <command-line-arguments.T4[a]> {arg1}
	t5 = Call <*command-line-arguments.T4[T any]> ir:wrapnilchk t3 t1 t2
	t6 = Load <command-line-arguments.T4[T any]> t5
	t7 = Call <()> (command-line-arguments.T4[a]).fn1 t6 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.T4[T any]).fn2
# Synthetic: wrapper
func (t3 *command-line-arguments.T4[T any]) fn2():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn2"}
	t3 = Parameter <*command-line-arguments.T4[T any]> {r}
	t4 = Call <*command-line-arguments.T4[T any]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.T4[T any]> t4
	t6 = Call <()> (command-line-arguments.T4[b]).fn2 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.T4[T any]).fn3
# Synthetic: wrapper
func (t3 *command-line-arguments.T4[T any]) fn3():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn3"}
	t3 = Parameter <*command-line-arguments.T4[T any]> {r}
	t4 = Call <*command-line-arguments.T4[T any]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.T4[T any]> t4
	t6 = Call <()> (command-line-arguments.T4[c]).fn3 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t1[a]).fn1
# Package: command-line-arguments
func (t1 t1[a]) fn1():
b0: # entry
	t1 = Parameter <t1[a]> {r}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t1[b]).fn2
# Package: command-line-arguments
func (t1 t1[b]) fn2():
b0: # entry
	t1 = Parameter <t1[b]> {r}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t1[c]).fn3
# Package: command-line-arguments
func (t1 t1[c]) fn3():
b0: # entry
	t1 = Parameter <t1[c]> {r}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t1[d]).fn1
# Synthetic: generic
func (t1 command-line-arguments.t1[d]) fn1():
b0: # entry
	t1 = Parameter <command-line-arguments.t1[d]> {r}
	t2 = ChangeType <command-line-arguments.t1[a]> t1
	t3 = Call <()> (command-line-arguments.t1[a]).fn1 d t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t1[d]).fn2
# Synthetic: generic
func (t1 command-line-arguments.t1[d]) fn2():
b0: # entry
	t1 = Parameter <command-line-arguments.t1[d]> {r}
	t2 = ChangeType <command-line-arguments.t1[b]> t1
	t3 = Call <()> (command-line-arguments.t1[b]).fn2 d t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t1[d]).fn3
# Synthetic: generic
func (t1 command-line-arguments.t1[d]) fn3():
b0: # entry
	t1 = Parameter <command-line-arguments.t1[d]> {r}
	t2 = ChangeType <command-line-arguments.t1[c]> t1
	t3 = Call <()> (command-line-arguments.t1[c]).fn3 d t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.t1[d]).fn1
# Synthetic: wrapper
func (t3 *command-line-arguments.t1[d]) fn1():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn1"}
	t3 = Parameter <*command-line-arguments.t1[d]> {r}
	t4 = Call <*command-line-arguments.t1[d]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.t1[d]> t4
	t6 = Call <()> (command-line-arguments.t1[d]).fn1 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.t1[d]).fn2
# Synthetic: wrapper
func (t3 *command-line-arguments.t1[d]) fn2():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn2"}
	t3 = Parameter <*command-line-arguments.t1[d]> {r}
	t4 = Call <*command-line-arguments.t1[d]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.t1[d]> t4
	t6 = Call <()> (command-line-arguments.t1[d]).fn2 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.t1[d]).fn3
# Synthetic: wrapper
func (t3 *command-line-arguments.t1[d]) fn3():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn3"}
	t3 = Parameter <*command-line-arguments.t1[d]> {r}
	t4 = Call <*command-line-arguments.t1[d]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.t1[d]> t4
	t6 = Call <()> (command-line-arguments.t1[d]).fn3 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.t1[d]).fn4
# Synthetic: wrapper
func (t3 *command-line-arguments.t1[d]) fn4():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"fn4"}
	t3 = Parameter <*command-line-arguments.t1[d]> {r}
	t4 = Call <*command-line-arguments.t1[d]> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.t1[d]> t4
	t6 = Call <()> (command-line-arguments.t1[d]).fn4 t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t1[d]).fn4
# Package: command-line-arguments
func (t1 t1[d]) fn4():
b0: # entry
	t1 = Parameter <t1[d]> {r}
	t2 = MakeInterface <interface{fn1(); fn2(); fn3(); fn4()}> t1
	BlankStore t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t2[a]).fn1
# Package: command-line-arguments
func (t1 t2[a]) fn1():
b0: # entry
	t1 = Parameter <t2[a]> {r}
	t2 = Call <()> (t2[a]).fn1 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t2[b]).fn1
# Synthetic: generic
func (t1 command-line-arguments.t2[b]) fn1():
b0: # entry
	t1 = Parameter <command-line-arguments.t2[b]> {r}
	t2 = ChangeType <command-line-arguments.t2[a]> t1
	t3 = Call <()> (command-line-arguments.t2[a]).fn1 b t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t2[b]).fn2
# Package: command-line-arguments
func (t1 t2[b]) fn2():
b0: # entry
	t1 = Parameter <t2[b]> {r}
	t2 = Call <()> (t2[b]).fn1 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t2[c]).fn1
# Synthetic: generic
func (t1 command-line-arguments.t2[c]) fn1():
b0: # entry
	t1 = Parameter <command-line-arguments.t2[c]> {r}
	t2 = ChangeType <command-line-arguments.t2[a]> t1
	t3 = Call <()> (command-line-arguments.t2[a]).fn1 c t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.t2[c]).fn3
# Package: command-line-arguments
func (t1 t2[c]) fn3():
b0: # entry
	t1 = Parameter <t2[c]> {r}
	t2 = Call <()> (t2[c]).fn1 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.T3[a]).fn1
# Package: command-line-arguments
func (t1 T3[a]) fn1():
b0: # entry
	t1 = Parameter <T3[a]> {r}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.T3[b]).fn2
# Package: command-line-arguments
func (t1 T3[b]) fn2():
b0: # entry
	t1 = Parameter <T3[b]> {r}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.T3[c]).fn3
# Package: command-line-arguments
func (t1 T3[c]) fn3():
b0: # entry
	t1 = Parameter <T3[c]> {r}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.T4[a]).fn1
# Package: command-line-arguments
func (t1 T4[a]) fn1(T4[a]):
b0: # entry
	t1 = Parameter <T4[a]> {r}
	t2 = Parameter <T4[a]> {arg1}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.T4[b]).fn2
# Package: command-line-arguments
func (t1 T4[b]) fn2():
b0: # entry
	t1 = Parameter <T4[b]> {r}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.T4[c]).fn3
# Package: command-line-arguments
func (t1 T4[c]) fn3():
b0: # entry
	t1 = Parameter <T4[c]> {r}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
