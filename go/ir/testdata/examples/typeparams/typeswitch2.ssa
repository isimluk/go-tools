# Name: command-line-arguments.f
# Package: command-line-arguments
# Locals:
#   0:	t13 struct{a T; b T}
func f[T any](i interface{}):
b0: # entry
	t1 = Const <int> {0}
	t2 = Const <int> {1}
	t3 = Const <int> {2}
	t4 = Const <int> {3}
	t5 = Const <int> {4}
	t6 = Const <int> {-1}
	t7 = Const <string> {"T"}
	t8 = Const <string> {"int"}
	t9 = Const <string> {"int32/int16"}
	t10 = Const <string> {"struct{T,T}"}
	t11 = Const <string> {"other"}
	t12 = Parameter <interface{}> {i}
	t13 = StackAlloc <*struct{a T; b T}>
	t14 = TypeSwitch <(index int, T, int, interface{}, interface{}, struct{a T; b T}, interface{})> t12 "T" "int" "int32" "int16" "struct{a T; b T}"
	t15 = Extract <int> [0] (index) t14
	ConstantSwitch t15 t1 t2 t3 t4 t5 t6 → b2 b3 b5 b6 b7 b8

b1: ← b2 b3 b4 b7 b8 # exit
	Return

b2: ← b0 # typeswitch.head
	t18 = Extract <T> [1] () t14
	t19 = Call <()> println t7 t18
	Jump → b1

b3: ← b0 # typeswitch.head
	t21 = Extract <int> [2] () t14
	t22 = Call <()> println t8 t21
	Jump → b1

b4: ← b5 b6 # typeswitch.body
	t24 = Phi <interface{}> 5:t29 6:t31
	t25 = Call <reflect.Value> reflect.ValueOf t24
	t26 = Call <int64> (reflect.Value).Int t25
	t27 = Call <()> println t9 t26
	Jump → b1

b5: ← b0 # typeswitch.head
	t29 = Extract <interface{}> [3] () t14
	Jump → b4

b6: ← b0 # typeswitch.head
	t31 = Extract <interface{}> [4] () t14
	Jump → b4

b7: ← b0 # typeswitch.head
	t33 = Extract <struct{a T; b T}> [5] () t14
	Store {struct{a T; b T}} t13 t33
	t35 = FieldAddr <*T> [0] (a) t13
	t36 = Load <T> t35
	t37 = FieldAddr <*T> [1] (b) t13
	t38 = Load <T> t37
	t39 = Call <()> println t10 t36 t38
	Jump → b1

b8: ← b0 # typeswitch.default
	t41 = Extract <interface{}> [6] () t14
	t42 = Call <reflect.Value> reflect.ValueOf t41
	t43 = Call <int64> (reflect.Value).Int t42
	t44 = Call <()> println t11 t43
	Jump → b1

# Name: f$generic#0
# Synthetic: generic
func f$generic#0(i interface{}):
b0: # entry
	t1 = Parameter <interface{}> {i}
	t2 = Call <()> command-line-arguments.f float64 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: f$generic#1
# Synthetic: generic
func f$generic#1(i interface{}):
b0: # entry
	t1 = Parameter <interface{}> {i}
	t2 = Call <()> command-line-arguments.f int32 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: f$generic#2
# Synthetic: generic
func f$generic#2(i interface{}):
b0: # entry
	t1 = Parameter <interface{}> {i}
	t2 = Call <()> command-line-arguments.f int t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.main
# Package: command-line-arguments
# Locals:
#   0:	t14 struct{a float64; b float64}
func main():
b0: # entry
	t1 = Const <float64> {6}
	t2 = Const <int> {7}
	t3 = Const <int32> {8}
	t4 = Const <float64> {1}
	t5 = Const <float64> {2}
	t6 = Const <int8> {9}
	t7 = Const <int32> {7}
	t8 = MakeInterface <interface{}> t1
	t9 = Call <()> f$generic#0 t8
	t10 = MakeInterface <interface{}> t2
	t11 = Call <()> f$generic#0 t10
	t12 = MakeInterface <interface{}> t3
	t13 = Call <()> f$generic#0 t12
	t14 = StackAlloc <*struct{a float64; b float64}>
	t15 = FieldAddr <*float64> [0] (a) t14
	t16 = FieldAddr <*float64> [1] (b) t14
	Store {float64} t15 t4
	Store {float64} t16 t5
	t19 = Load <struct{a float64; b float64}> t14
	t20 = MakeInterface <interface{}> t19
	t21 = Call <()> f$generic#0 t20
	t22 = MakeInterface <interface{}> t6
	t23 = Call <()> f$generic#0 t22
	t24 = MakeInterface <interface{}> t7
	t25 = Call <()> f$generic#1 t24
	t26 = MakeInterface <interface{}> t7
	t27 = Call <()> f$generic#2 t26
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	t6 = Call <()> reflect.init
	Jump → b1
