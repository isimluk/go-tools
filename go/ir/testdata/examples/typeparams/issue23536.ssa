# Name: command-line-arguments.f
# Package: command-line-arguments
func f[T []MyByte](x T) string:
b0: # entry
	t1 = Parameter <T> {x}
	t2 = Convert <string> t1
	Jump → b1

b1: ← b0 # exit
	Return t2

# Name: command-line-arguments.g
# Package: command-line-arguments
func g[T []MyRune](x T) string:
b0: # entry
	t1 = Parameter <T> {x}
	t2 = Convert <string> t1
	Jump → b1

b1: ← b0 # exit
	Return t2

# Name: f$generic#0
# Synthetic: generic
func f$generic#0(x []command-line-arguments.MyByte) string:
b0: # entry
	t1 = Parameter <[]command-line-arguments.MyByte> {x}
	t2 = ChangeType <T> t1
	t3 = Call <string> command-line-arguments.f []command-line-arguments.MyByte t2
	Jump → b1

b1: ← b0 # exit
	Return t3

# Name: g$generic#0
# Synthetic: generic
func g$generic#0(x []command-line-arguments.MyRune) string:
b0: # entry
	t1 = Parameter <[]command-line-arguments.MyRune> {x}
	t2 = ChangeType <T> t1
	t3 = Call <string> command-line-arguments.g []command-line-arguments.MyRune t2
	Jump → b1

b1: ← b0 # exit
	Return t3

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <[]MyByte> {nil}
	t2 = Const <[]MyRune> {nil}
	t3 = Call <string> f$generic#0 t1
	BlankStore t3
	t5 = Convert <string> t1
	BlankStore t5
	t7 = Call <string> g$generic#0 t2
	BlankStore t7
	t9 = Convert <string> t2
	BlankStore t9
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
