# Name: command-line-arguments._Append
# Package: command-line-arguments
func _Append[a sliceOf[b], b any](s a, t ...b) a:
b0: # entry
	t1 = Parameter <a> {s}
	t2 = Parameter <[]b> {t}
	t3 = Call <a> append t1 t2
	Jump → b1

b1: ← b0 # exit
	Return t3

# Name: _Append$generic#0
# Synthetic: generic
func _Append$generic#0(s []command-line-arguments.Recv, t ...command-line-arguments.Recv) []command-line-arguments.Recv:
b0: # entry
	t1 = Parameter <[]command-line-arguments.Recv> {s}
	t2 = Parameter <[]command-line-arguments.Recv> {t}
	t3 = ChangeType <a> t1
	t4 = ChangeType <[]b> t2
	t5 = Call <a> command-line-arguments._Append []command-line-arguments.Recv command-line-arguments.Recv t3 t4
	t6 = ChangeType <[]command-line-arguments.Recv> t5
	Jump → b1

b1: ← b0 # exit
	Return t6

# Name: _Append$generic#1
# Synthetic: generic
func _Append$generic#1(s []chan<- int, t ...chan<- int) []chan<- int:
b0: # entry
	t1 = Parameter <[]chan<- int> {s}
	t2 = Parameter <[]chan<- int> {t}
	t3 = ChangeType <a> t1
	t4 = ChangeType <[]b> t2
	t5 = Call <a> command-line-arguments._Append []chan<- int chan<- int t3 t4
	t6 = ChangeType <[]chan<- int> t5
	Jump → b1

b1: ← b0 # exit
	Return t6

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <int> {0}
	t2 = Const <int> {2}
	t3 = Const <int> {1}
	t4 = MakeChan <Recv> t1
	t5 = HeapAlloc <*[1]Recv>
	t6 = IndexAddr <*Recv> t5 t1
	Store {command-line-arguments.Recv} t6 t4
	t8 = Slice <[]Recv> t5 <nil> <nil> <nil>
	t9 = HeapAlloc <*[1]Recv>
	t10 = IndexAddr <*Recv> t9 t1
	Store {command-line-arguments.Recv} t10 t4
	t12 = Slice <[]Recv> t9 <nil> <nil> <nil>
	t13 = Call <[]Recv> _Append$generic#0 t8 t12
	t14 = Call <int> len t13
	t15 = BinOp <bool> {!=} t14 t2
	If t15 → b2 b5

b1: ← b2 b6 b7 # exit
	Return

b2: ← b0 b5 b4 # if.then
	t18 = Sigma <[]Recv> [b0] t13
	t19 = Sigma <[]Recv> [b5] t45
	t20 = Sigma <[]Recv> [b4] t39
	t21 = Phi <[]command-line-arguments.Recv> 0:t18 5:t19 4:t20
	t22 = MakeInterface <interface{}> t21
	Panic t22 → b1

b3: ← b4 # if.done
	t24 = Sigma <[]Recv> [b4] t39
	t25 = MakeChan <chan<- int> t1
	t26 = HeapAlloc <*[1]chan<- int>
	t27 = IndexAddr <*chan<- int> t26 t1
	Store {chan<- int} t27 t25
	t29 = Slice <[]chan<- int> t26 <nil> <nil> <nil>
	t30 = HeapAlloc <*[1]chan<- int>
	t31 = IndexAddr <*chan<- int> t30 t1
	Store {chan<- int} t31 t25
	t33 = Slice <[]chan<- int> t30 <nil> <nil> <nil>
	t34 = Call <[]chan<- int> _Append$generic#1 t29 t33
	t35 = Call <int> len t34
	t36 = BinOp <bool> {!=} t35 t2
	If t36 → b6 b8

b4: ← b5 # cond.false
	t38 = Sigma <Recv> [b5] t44
	t39 = Sigma <[]Recv> [b5] t45
	t40 = IndexAddr <*Recv> t39 t3
	t41 = Load <Recv> t40
	t42 = BinOp <bool> {!=} t41 t38
	If t42 → b2 b3

b5: ← b0 # cond.false
	t44 = Sigma <Recv> [b0] t4
	t45 = Sigma <[]Recv> [b0] t13
	t46 = IndexAddr <*Recv> t45 t1
	t47 = Load <Recv> t46
	t48 = BinOp <bool> {!=} t47 t44
	If t48 → b2 b4

b6: ← b3 b8 b7 # if.then
	t50 = Sigma <[]Recv> [b3] t24
	t51 = Sigma <[]Recv> [b8] t63
	t52 = Sigma <[]Recv> [b7] t56
	t53 = Phi <[]command-line-arguments.Recv> 3:t50 8:t51 7:t52
	t54 = MakeInterface <interface{}> t53
	Panic t54 → b1

b7: ← b8 # cond.false
	t56 = Sigma <[]Recv> [b8] t63
	t57 = Sigma <chan<- int> [b8] t64
	t58 = Sigma <[]chan<- int> [b8] t65
	t59 = IndexAddr <*chan<- int> t58 t3
	t60 = Load <chan<- int> t59
	t61 = BinOp <bool> {!=} t60 t57
	If t61 → b6 b1

b8: ← b3 # cond.false
	t63 = Sigma <[]Recv> [b3] t24
	t64 = Sigma <chan<- int> [b3] t25
	t65 = Sigma <[]chan<- int> [b3] t34
	t66 = IndexAddr <*chan<- int> t65 t1
	t67 = Load <chan<- int> t66
	t68 = BinOp <bool> {!=} t67 t64
	If t68 → b6 b7

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
