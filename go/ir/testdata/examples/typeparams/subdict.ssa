# Name: (*command-line-arguments.value[T]).test
# Package: command-line-arguments
func (t1 *value[T]) test(def T) bool:
b0: # entry
	t1 = Parameter <*value[T]> {v}
	t2 = Parameter <T> {def}
	t3 = FieldAddr <*T> [0] (val) t1
	t4 = Load <T> t3
	t5 = BinOp <bool> {==} t4 t2
	Jump → b1

b1: ← b0 # exit
	Return t5

# Name: (*command-line-arguments.value[int]).test
# Synthetic: generic
func (t1 *command-line-arguments.value[int]) test(def int) bool:
b0: # entry
	t1 = Parameter <*command-line-arguments.value[int]> {v}
	t2 = Parameter <int> {def}
	t3 = ChangeType <*command-line-arguments.value[T]> t1
	t4 = ChangeType <T> t2
	t5 = Call <bool> (*command-line-arguments.value[T]).test int t3 t4
	Jump → b1

b1: ← b0 # exit
	Return t5

# Name: (*command-line-arguments.value[T]).get
# Package: command-line-arguments
func (t2 *value[T]) get(def T) T:
b0: # entry
	t1 = Const <int> {32}
	t2 = Parameter <*value[T]> {v}
	t3 = Parameter <T> {def}
	t4 = HeapAlloc <*value[int]>
	t5 = Call <bool> (*value[int]).test t4 t1
	If t5 → b2 b3

b1: ← b2 b4 b5 # exit
	t7 = Phi <T> 2:t9 4:t15 5:t19
	Return t7

b2: ← b0 # if.then
	t9 = Sigma <T> [b0] t3
	Jump → b1

b3: ← b0 # if.else
	t11 = Sigma <*value[T]> [b0] t2
	t12 = Sigma <T> [b0] t3
	t13 = Call <bool> (*value[T]).test t11 t12
	If t13 → b4 b5

b4: ← b3 # if.then
	t15 = Sigma <T> [b3] t12
	Jump → b1

b5: ← b3 # if.else
	t17 = Sigma <*value[T]> [b3] t11
	t18 = FieldAddr <*T> [0] (val) t17
	t19 = Load <T> t18
	Jump → b1

# Name: (*command-line-arguments.value[string]).get
# Synthetic: generic
func (t1 *command-line-arguments.value[string]) get(def string) string:
b0: # entry
	t1 = Parameter <*command-line-arguments.value[string]> {v}
	t2 = Parameter <string> {def}
	t3 = ChangeType <*command-line-arguments.value[T]> t1
	t4 = ChangeType <T> t2
	t5 = Call <T> (*command-line-arguments.value[T]).get string t3 t4
	t6 = ChangeType <string> t5
	Jump → b1

b1: ← b0 # exit
	Return t6

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <string> {"ab"}
	t2 = Const <string> {""}
	t3 = Const <string> {"get() == %d, want %d"}
	t4 = Const <int> {0}
	t5 = Const <int> {1}
	t6 = HeapAlloc <*value[string]>
	t7 = Call <string> (*value[string]).get t6 t1
	t8 = BinOp <bool> {!=} t7 t2
	If t8 → b2 b1

b1: ← b2 b0 # exit
	Return

b2: ← b0 # if.then
	t11 = Sigma <string> [b0] t7
	t12 = Sigma <string> [b0] t2
	t13 = HeapAlloc <*[2]any>
	t14 = IndexAddr <*any> t13 t4
	t15 = MakeInterface <any> t11
	Store {any} t14 t15
	t17 = IndexAddr <*any> t13 t5
	t18 = MakeInterface <any> t12
	Store {any} t17 t18
	t20 = Slice <[]any> t13 <nil> <nil> <nil>
	t21 = Call <string> fmt.Sprintf t3 t20
	t22 = MakeInterface <interface{}> t21
	Panic t22 → b1

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	t6 = Call <()> fmt.init
	Jump → b1
