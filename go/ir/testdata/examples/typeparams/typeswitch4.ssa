# Name: (command-line-arguments.myint).foo
# Package: command-line-arguments
func (t1 myint) foo() int:
b0: # entry
	t1 = Parameter <myint> {x}
	t2 = ChangeType <int> t1
	Jump → b1

b1: ← b0 # exit
	Return t2

# Name: (command-line-arguments.myfloat).foo
# Package: command-line-arguments
func (t1 myfloat) foo() int:
b0: # entry
	t1 = Parameter <myfloat> {x}
	t2 = Convert <int> t1
	Jump → b1

b1: ← b0 # exit
	Return t2

# Name: (command-line-arguments.myint32).foo
# Package: command-line-arguments
func (t1 myint32) foo() int:
b0: # entry
	t1 = Parameter <myint32> {x}
	t2 = Convert <int> t1
	Jump → b1

b1: ← b0 # exit
	Return t2

# Name: command-line-arguments.f
# Package: command-line-arguments
func f[T I](i I):
b0: # entry
	t1 = Const <int> {0}
	t2 = Const <int> {1}
	t3 = Const <int> {-1}
	t4 = Const <string> {"T/myint32"}
	t5 = Const <string> {"other"}
	t6 = Parameter <I> {i}
	t7 = TypeSwitch <(index int, I, I, I)> t6 "T" "myint32"
	t8 = Extract <int> [0] (index) t7
	ConstantSwitch t8 t1 t2 t3 → b3 b4 b5

b1: ← b2 b5 # exit
	Return

b2: ← b3 b4 # typeswitch.body
	t11 = Phi <command-line-arguments.I> 3:t15 4:t17
	t12 = CallInvoke <int> t11.foo
	t13 = Call <()> println t4 t12
	Jump → b1

b3: ← b0 # typeswitch.head
	t15 = Extract <I> [1] () t7
	Jump → b2

b4: ← b0 # typeswitch.head
	t17 = Extract <I> [2] () t7
	Jump → b2

b5: ← b0 # typeswitch.default
	t19 = Extract <I> [3] () t7
	t20 = CallInvoke <int> t19.foo
	t21 = Call <()> println t5 t20
	Jump → b1

# Name: f$generic#0
# Synthetic: generic
func f$generic#0(i command-line-arguments.I):
b0: # entry
	t1 = Parameter <command-line-arguments.I> {i}
	t2 = Call <()> command-line-arguments.f command-line-arguments.myfloat t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.myint).foo
# Synthetic: wrapper
func (t3 *command-line-arguments.myint) foo() int:
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"foo"}
	t3 = Parameter <*command-line-arguments.myint> {x}
	t4 = Call <*command-line-arguments.myint> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.myint> t4
	t6 = Call <int> (command-line-arguments.myint).foo t5
	Jump → b1

b1: ← b0 # exit
	Return t6

# Name: (*command-line-arguments.myfloat).foo
# Synthetic: wrapper
func (t3 *command-line-arguments.myfloat) foo() int:
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"foo"}
	t3 = Parameter <*command-line-arguments.myfloat> {x}
	t4 = Call <*command-line-arguments.myfloat> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.myfloat> t4
	t6 = Call <int> (command-line-arguments.myfloat).foo t5
	Jump → b1

b1: ← b0 # exit
	Return t6

# Name: (*command-line-arguments.myint32).foo
# Synthetic: wrapper
func (t3 *command-line-arguments.myint32) foo() int:
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"foo"}
	t3 = Parameter <*command-line-arguments.myint32> {x}
	t4 = Call <*command-line-arguments.myint32> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.myint32> t4
	t6 = Call <int> (command-line-arguments.myint32).foo t5
	Jump → b1

b1: ← b0 # exit
	Return t6

# Name: f$generic#1
# Synthetic: generic
func f$generic#1(i command-line-arguments.I):
b0: # entry
	t1 = Parameter <command-line-arguments.I> {i}
	t2 = Call <()> command-line-arguments.f command-line-arguments.myint32 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: f$generic#2
# Synthetic: generic
func f$generic#2(i command-line-arguments.I):
b0: # entry
	t1 = Parameter <command-line-arguments.I> {i}
	t2 = Call <()> command-line-arguments.f command-line-arguments.myint t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <myint> {6}
	t2 = Const <myfloat> {7}
	t3 = Const <myint32> {8}
	t4 = Const <myint32> {9}
	t5 = Const <myint32> {10}
	t6 = Const <myfloat> {42}
	t7 = MakeInterface <I> t1
	t8 = Call <()> f$generic#0 t7
	t9 = MakeInterface <I> t2
	t10 = Call <()> f$generic#0 t9
	t11 = MakeInterface <I> t3
	t12 = Call <()> f$generic#0 t11
	t13 = MakeInterface <I> t4
	t14 = Call <()> f$generic#1 t13
	t15 = MakeInterface <I> t5
	t16 = Call <()> f$generic#2 t15
	t17 = MakeInterface <I> t6
	t18 = Call <()> f$generic#2 t17
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
