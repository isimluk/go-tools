# Name: (*command-line-arguments.BImpl).Work
# Synthetic: wrapper
func (t3 *command-line-arguments.BImpl) Work(s string):
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"Work"}
	t3 = Parameter <*command-line-arguments.BImpl> {b}
	t4 = Parameter <string> {s}
	t5 = Call <*command-line-arguments.BImpl> ir:wrapnilchk t3 t1 t2
	t6 = Load <command-line-arguments.BImpl> t5
	t7 = Call <()> (command-line-arguments.BImpl).Work t6 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.A[T]).Work
# Package: command-line-arguments
func (t1 *A[T]) Work(t T):
b0: # entry
	t1 = Parameter <*A[T]> {a}
	t2 = Parameter <T> {t}
	t3 = FieldAddr <*B[T]> [0] (field) t1
	t4 = Load <B[T]> t3
	t5 = CallInvoke <()> t4.Work t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (command-line-arguments.BImpl).Work
# Package: command-line-arguments
func (t1 BImpl) Work(s string):
b0: # entry
	t1 = Parameter <BImpl> {b}
	t2 = Parameter <string> {s}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.A[string]).Work
# Synthetic: generic
func (t1 *command-line-arguments.A[string]) Work(t string):
b0: # entry
	t1 = Parameter <*command-line-arguments.A[string]> {a}
	t2 = Parameter <string> {t}
	t3 = ChangeType <*command-line-arguments.A[T]> t1
	t4 = ChangeType <T> t2
	t5 = Call <()> (*command-line-arguments.A[T]).Work string t3 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <string> {""}
	t2 = AggregateConst <BImpl> ()
	t3 = HeapAlloc <*A[string]>
	t4 = FieldAddr <*B[string]> [0] (field) t3
	t5 = MakeInterface <B[string]> t2
	Store {command-line-arguments.B[string]} t4 t5
	t7 = Call <()> (*A[string]).Work t3 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
