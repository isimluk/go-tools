# Name: (command-line-arguments.myint).foo
# Package: command-line-arguments
func (t1 myint) foo() int:
b0: # entry
	t1 = Parameter <myint> {x}
	t2 = ChangeType <int> t1
	Jump → b1

b1: ← b0 # exit
	Return t2

# Name: (command-line-arguments.myfloat).foo
# Package: command-line-arguments
func (t1 myfloat) foo() float64:
b0: # entry
	t1 = Parameter <myfloat> {x}
	t2 = ChangeType <float64> t1
	Jump → b1

b1: ← b0 # exit
	Return t2

# Name: command-line-arguments.f
# Package: command-line-arguments
func f[T any](i interface{}):
b0: # entry
	t1 = Const <int> {0}
	t2 = Const <int> {-1}
	t3 = Const <string> {"fooer"}
	t4 = Const <string> {"other"}
	t5 = Parameter <interface{}> {i}
	t6 = TypeSwitch <(index int, interface{foo() T}, interface{})> t5 "interface{foo() T}"
	t7 = Extract <int> [0] (index) t6
	ConstantSwitch t7 t1 t2 → b2 b3

b1: ← b2 b3 # exit
	Return

b2: ← b0 # typeswitch.head
	t10 = Extract <interface{foo() T}> [1] () t6
	t11 = CallInvoke <T> t10.foo
	t12 = Call <()> println t3 t11
	Jump → b1

b3: ← b0 # typeswitch.default
	t14 = Extract <interface{}> [2] () t6
	t15 = Call <()> println t4
	Jump → b1

# Name: f$generic#0
# Synthetic: generic
func f$generic#0(i interface{}):
b0: # entry
	t1 = Parameter <interface{}> {i}
	t2 = Call <()> command-line-arguments.f int t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.myint).foo
# Synthetic: wrapper
func (t3 *command-line-arguments.myint) foo() int:
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"foo"}
	t3 = Parameter <*command-line-arguments.myint> {x}
	t4 = Call <*command-line-arguments.myint> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.myint> t4
	t6 = Call <int> (command-line-arguments.myint).foo t5
	Jump → b1

b1: ← b0 # exit
	Return t6

# Name: (*command-line-arguments.myfloat).foo
# Synthetic: wrapper
func (t3 *command-line-arguments.myfloat) foo() float64:
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"foo"}
	t3 = Parameter <*command-line-arguments.myfloat> {x}
	t4 = Call <*command-line-arguments.myfloat> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.myfloat> t4
	t6 = Call <float64> (command-line-arguments.myfloat).foo t5
	Jump → b1

b1: ← b0 # exit
	Return t6

# Name: f$generic#1
# Synthetic: generic
func f$generic#1(i interface{}):
b0: # entry
	t1 = Parameter <interface{}> {i}
	t2 = Call <()> command-line-arguments.f float64 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <myint> {6}
	t2 = Const <myfloat> {7}
	t3 = Const <myint> {8}
	t4 = Const <myfloat> {9}
	t5 = MakeInterface <interface{}> t1
	t6 = Call <()> f$generic#0 t5
	t7 = MakeInterface <interface{}> t2
	t8 = Call <()> f$generic#0 t7
	t9 = MakeInterface <interface{}> t3
	t10 = Call <()> f$generic#1 t9
	t11 = MakeInterface <interface{}> t4
	t12 = Call <()> f$generic#1 t11
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
