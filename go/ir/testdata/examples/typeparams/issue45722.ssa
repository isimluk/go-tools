# Name: command-line-arguments.try
# Package: command-line-arguments
func try[T any](v T, err error) T:
b0: # entry
	t1 = Const <error> {nil}
	t2 = GenericConst <T>
	t3 = Parameter <T> {v}
	t4 = Parameter <error> {err}
	t5 = BinOp <bool> {!=} t4 t1
	If t5 → b2 b3

b1: ← b2 b3 # exit
	t7 = Phi <T> 2:t10 3:t13
	Return t7

b2: ← b0 # if.then
	t9 = Sigma <error> [b0] t4
	t10 = Sigma <T> [b0] t2
	t11 = ChangeInterface <interface{}> t9
	Panic t11 → b1

b3: ← b0 # if.done
	t13 = Sigma <T> [b0] t3
	Jump → b1

# Name: command-line-arguments.handle
# Package: command-line-arguments
func handle(handle func(error)):
b0: # entry
	t1 = Const <interface{}> {nil}
	t2 = Const <error> {nil}
	t3 = Const <string> {"%v"}
	t4 = Const <int> {0}
	t5 = Parameter <func(error)> {handle}
	t6 = Call <interface{}> recover
	t7 = BinOp <bool> {!=} t6 t1
	If t7 → b2 b1

b1: ← b0 b3 b4 # exit
	Return

b2: ← b0 # if.then
	t10 = Sigma <func(error)> [b0] t5
	t11 = Sigma <interface{}> [b0] t6
	t12 = TypeAssert <(value error, ok bool)> t11
	t13 = Extract <error> [0] (value) t12
	t14 = Extract <bool> [1] (ok) t12
	If t14 → b5 b4

b3: ← b5 # if.then
	t16 = Sigma <func(error)> [b5] t34
	t17 = Sigma <error> [b5] t35
	t18 = Call <()> t16 t17
	Jump → b1

b4: ← b2 b5 # if.else
	t20 = Sigma <func(error)> [b2] t10
	t21 = Sigma <error> [b2] t13
	t22 = Sigma <func(error)> [b5] t34
	t23 = Sigma <error> [b5] t35
	t24 = Phi <func(error)> 2:t20 5:t22
	t25 = Phi <error> 2:t21 5:t23
	t26 = HeapAlloc <*[1]any>
	t27 = IndexAddr <*any> t26 t4
	t28 = ChangeInterface <any> t25
	Store {any} t27 t28
	t30 = Slice <[]any> t26 <nil> <nil> <nil>
	t31 = Call <error> fmt.Errorf t3 t30
	t32 = Call <()> t24 t31
	Jump → b1

b5: ← b2 # cond.true
	t34 = Sigma <func(error)> [b2] t10
	t35 = Sigma <error> [b2] t13
	t36 = BinOp <bool> {!=} t35 t2
	If t36 → b3 b4

# Name: command-line-arguments.main$1
# Package: command-line-arguments
# Parent: main
func main$1(e error):
b0: # entry
	t1 = Const <int> {0}
	t2 = Parameter <error> {e}
	t3 = HeapAlloc <*[1]any>
	t4 = IndexAddr <*any> t3 t1
	t5 = ChangeInterface <any> t2
	Store {any} t4 t5
	t7 = Slice <[]any> t3 <nil> <nil> <nil>
	t8 = Call <()> log.Fatalln t7
	Jump → b1

b1: ← b0 # exit
	Return

# Name: try$generic#0
# Synthetic: generic
func try$generic#0(v int, err error) int:
b0: # entry
	t1 = Parameter <int> {v}
	t2 = Parameter <error> {err}
	t3 = ChangeType <T> t1
	t4 = Call <T> command-line-arguments.try int t3 t2
	t5 = ChangeType <int> t4
	Jump → b1

b1: ← b0 # exit
	Return t5

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <string> {""}
	t2 = Const <int> {0}
	Defer handle main$1
	t4 = HeapAlloc <*[1]any>
	t5 = IndexAddr <*any> t4 t2
	t6 = MakeInterface <any> t1
	Store {any} t5 t6
	t8 = Slice <[]any> t4 <nil> <nil> <nil>
	t9 = Call <(n int, err error)> fmt.Print t8
	t10 = Extract <int> [0] (n) t9
	t11 = Extract <error> [1] (err) t9
	t12 = Call <int> try$generic#0 t10 t11
	BlankStore t12
	Jump → b1

b1: ← b0 # exit
	RunDefers
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	t6 = Call <()> fmt.init
	t7 = Call <()> log.init
	Jump → b1
