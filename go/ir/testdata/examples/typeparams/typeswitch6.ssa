# Name: command-line-arguments.f
# Package: command-line-arguments
func f[T any](i interface{}):
b0: # entry
	t1 = Const <int> {0}
	t2 = Const <int> {1}
	t3 = Const <int> {-1}
	t4 = Const <string> {"T"}
	t5 = Const <string> {"int"}
	t6 = Const <string> {"other"}
	t7 = Parameter <interface{}> {i}
	t8 = TypeSwitch <(index int, T, int, interface{})> t7 "T" "int"
	t9 = Extract <int> [0] (index) t8
	ConstantSwitch t9 t1 t2 t3 → b2 b3 b4

b1: ← b2 b3 b4 # exit
	Return

b2: ← b0 # typeswitch.head
	t12 = Call <()> println t4
	Jump → b1

b3: ← b0 # typeswitch.head
	t14 = Call <()> println t5
	Jump → b1

b4: ← b0 # typeswitch.default
	t16 = Call <()> println t6
	Jump → b1

# Name: (command-line-arguments.myint).foo
# Package: command-line-arguments
func (t1 myint) foo():
b0: # entry
	t1 = Parameter <myint> {arg0}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: f$generic#0
# Synthetic: generic
func f$generic#0(i interface{}):
b0: # entry
	t1 = Parameter <interface{}> {i}
	t2 = Call <()> command-line-arguments.f interface{} t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: f$generic#1
# Synthetic: generic
func f$generic#1(i interface{}):
b0: # entry
	t1 = Parameter <interface{}> {i}
	t2 = Call <()> command-line-arguments.f interface{foo()} t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.myint).foo
# Synthetic: wrapper
func (t3 *command-line-arguments.myint) foo():
b0: # entry
	t1 = Const <string> {"command-line-argu..."}
	t2 = Const <string> {"foo"}
	t3 = Parameter <*command-line-arguments.myint> {arg0}
	t4 = Call <*command-line-arguments.myint> ir:wrapnilchk t3 t1 t2
	t5 = Load <command-line-arguments.myint> t4
	t6 = Call <()> (command-line-arguments.myint).foo t5
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <interface{}> {nil}
	t2 = Const <int> {6}
	t3 = Const <int> {7}
	t4 = Const <myint> {8}
	t5 = Call <()> f$generic#0 t1
	t6 = MakeInterface <interface{}> t2
	t7 = Call <()> f$generic#0 t6
	t8 = Call <()> f$generic#1 t1
	t9 = MakeInterface <interface{}> t3
	t10 = Call <()> f$generic#1 t9
	t11 = MakeInterface <interface{}> t4
	t12 = Call <()> f$generic#1 t11
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
