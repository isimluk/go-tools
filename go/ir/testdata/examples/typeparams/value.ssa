# Name: command-line-arguments.get
# Package: command-line-arguments
func get[T any](v *value[T]) T:
b0: # entry
	t1 = Parameter <*value[T]> {v}
	t2 = FieldAddr <*T> [0] (val) t1
	t3 = Load <T> t2
	Jump → b1

b1: ← b0 # exit
	Return t3

# Name: command-line-arguments.set
# Package: command-line-arguments
func set[T any](v *value[T], val T):
b0: # entry
	t1 = Parameter <*value[T]> {v}
	t2 = Parameter <T> {val}
	t3 = FieldAddr <*T> [0] (val) t1
	Store {T} t3 t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.value[T]).set
# Package: command-line-arguments
func (t1 *value[T]) set(val T):
b0: # entry
	t1 = Parameter <*value[T]> {v}
	t2 = Parameter <T> {val}
	t3 = FieldAddr <*T> [0] (val) t1
	Store {T} t3 t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.value[T]).get
# Package: command-line-arguments
func (t1 *value[T]) get() T:
b0: # entry
	t1 = Parameter <*value[T]> {v}
	t2 = FieldAddr <*T> [0] (val) t1
	t3 = Load <T> t2
	Jump → b1

b1: ← b0 # exit
	Return t3

# Name: set$generic#0
# Synthetic: generic
func set$generic#0(v *command-line-arguments.value[int], val int):
b0: # entry
	t1 = Parameter <*command-line-arguments.value[int]> {v}
	t2 = Parameter <int> {val}
	t3 = ChangeType <*command-line-arguments.value[T]> t1
	t4 = ChangeType <T> t2
	t5 = Call <()> command-line-arguments.set int t3 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: get$generic#0
# Synthetic: generic
func get$generic#0(v *command-line-arguments.value[int]) int:
b0: # entry
	t1 = Parameter <*command-line-arguments.value[int]> {v}
	t2 = ChangeType <*command-line-arguments.value[T]> t1
	t3 = Call <T> command-line-arguments.get int t2
	t4 = ChangeType <int> t3
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: (*command-line-arguments.value[int]).set
# Synthetic: generic
func (t1 *command-line-arguments.value[int]) set(val int):
b0: # entry
	t1 = Parameter <*command-line-arguments.value[int]> {v}
	t2 = Parameter <int> {val}
	t3 = ChangeType <*command-line-arguments.value[T]> t1
	t4 = ChangeType <T> t2
	t5 = Call <()> (*command-line-arguments.value[T]).set int t3 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.value[int]).get
# Synthetic: generic
func (t1 *command-line-arguments.value[int]) get() int:
b0: # entry
	t1 = Parameter <*command-line-arguments.value[int]> {v}
	t2 = ChangeType <*command-line-arguments.value[T]> t1
	t3 = Call <T> (*command-line-arguments.value[T]).get int t2
	t4 = ChangeType <int> t3
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: set$generic#1
# Synthetic: generic
func set$generic#1(v *command-line-arguments.value[string], val string):
b0: # entry
	t1 = Parameter <*command-line-arguments.value[string]> {v}
	t2 = Parameter <string> {val}
	t3 = ChangeType <*command-line-arguments.value[T]> t1
	t4 = ChangeType <T> t2
	t5 = Call <()> command-line-arguments.set string t3 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: get$generic#1
# Synthetic: generic
func get$generic#1(v *command-line-arguments.value[string]) string:
b0: # entry
	t1 = Parameter <*command-line-arguments.value[string]> {v}
	t2 = ChangeType <*command-line-arguments.value[T]> t1
	t3 = Call <T> command-line-arguments.get string t2
	t4 = ChangeType <string> t3
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: (*command-line-arguments.value[string]).set
# Synthetic: generic
func (t1 *command-line-arguments.value[string]) set(val string):
b0: # entry
	t1 = Parameter <*command-line-arguments.value[string]> {v}
	t2 = Parameter <string> {val}
	t3 = ChangeType <*command-line-arguments.value[T]> t1
	t4 = ChangeType <T> t2
	t5 = Call <()> (*command-line-arguments.value[T]).set string t3 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: (*command-line-arguments.value[string]).get
# Synthetic: generic
func (t1 *command-line-arguments.value[string]) get() string:
b0: # entry
	t1 = Parameter <*command-line-arguments.value[string]> {v}
	t2 = ChangeType <*command-line-arguments.value[T]> t1
	t3 = Call <T> (*command-line-arguments.value[T]).get string t2
	t4 = ChangeType <string> t3
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: command-line-arguments.main
# Package: command-line-arguments
func main():
b0: # entry
	t1 = Const <int> {1}
	t2 = Const <int> {2}
	t3 = Const <int> {3}
	t4 = Const <int> {4}
	t5 = Const <string> {"a"}
	t6 = Const <string> {"b"}
	t7 = Const <string> {"c"}
	t8 = Const <string> {"d"}
	t9 = HeapAlloc <*value[int]>
	t10 = Call <()> set$generic#0 t9 t1
	t11 = Call <int> get$generic#0 t9
	t12 = Call <()> (*value[int]).set t9 t2
	t13 = Call <int> (*value[int]).get t9
	t14 = HeapAlloc <*value[int]>
	t15 = Call <()> set$generic#0 t14 t3
	t16 = Call <int> get$generic#0 t14
	t17 = Call <()> (*value[int]).set t14 t4
	t18 = Call <int> (*value[int]).get t14
	t19 = HeapAlloc <*value[string]>
	t20 = Call <()> set$generic#1 t19 t5
	t21 = Call <string> get$generic#1 t19
	t22 = Call <()> (*value[string]).set t19 t6
	t23 = Call <string> get$generic#1 t19
	t24 = HeapAlloc <*value[string]>
	t25 = Call <()> set$generic#1 t24 t7
	t26 = Call <string> get$generic#1 t24
	t27 = Call <()> (*value[string]).set t24 t8
	t28 = Call <string> (*value[string]).get t24
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
