# Name: command-line-arguments.fn0
# Package: command-line-arguments
func fn0[T interface{}, PT interface{~*T}](x T) PT:
b0: # entry
	t1 = Parameter <T> {x}
	t2 = HeapAlloc <*T>
	Store {T} t2 t1
	t4 = ChangeType <PT> t2
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: command-line-arguments.at
# Package: command-line-arguments
func at[T interface{~[]E}, E any](x T, i int) E:
b0: # entry
	t1 = Parameter <T> {x}
	t2 = Parameter <int> {i}
	t3 = IndexAddr <*E> t1 t2
	t4 = Load <E> t3
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: command-line-arguments.fn1
# Package: command-line-arguments
func fn1[T interface{~int}](x T):
b0: # entry
	t1 = Const <T> {42}
	t2 = Const <myint> {42}
	t3 = Parameter <T> {x}
	t4 = ChangeType <int> t3
	BlankStore t4
	BlankStore t1
	t7 = ChangeType <T> t2
	BlankStore t7
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.fn2
# Package: command-line-arguments
# Locals:
#   0:	t3 T
func fn2[T interface{~[10]int}](x T):
b0: # entry
	t1 = Const <int> {9}
	t2 = Parameter <T> {x}
	t3 = StackAlloc <*T>
	Store {T} t3 t2
	t5 = IndexAddr <*int> t3 t1
	t6 = Load <int> t5
	BlankStore t6
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.fn3
# Package: command-line-arguments
func fn3[T interface{~*int}](p T) int:
b0: # entry
	t1 = Parameter <T> {p}
	t2 = Load <int> t1
	Jump → b1

b1: ← b0 # exit
	Return t2

# Name: command-line-arguments.fn4
# Package: command-line-arguments
func fn4[T interface{~chan int}](ch T) int:
b0: # entry
	t1 = Const <int> {0}
	t2 = Parameter <T> {ch}
	Send t2 t1
	t4 = Recv <int> t2
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: command-line-arguments.fn5
# Package: command-line-arguments
func fn5[T interface{~func()}](f T):
b0: # entry
	t1 = Parameter <T> {f}
	t2 = Call <()> t1
	Go t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.fn6
# Package: command-line-arguments
func fn6[T interface{~func(string) int}](f T) int:
b0: # entry
	t1 = Const <string> {"hello"}
	t2 = Parameter <T> {f}
	t3 = Call <int> t2 t1
	Jump → b1

b1: ← b0 # exit
	Return t3

# Name: command-line-arguments.fn7
# Package: command-line-arguments
func fn7[V any, T interface{~map[string]V}](p T) V:
b0: # entry
	t1 = Const <string> {"test"}
	t2 = Parameter <T> {p}
	t3 = MapLookup <V> t2 t1
	Jump → b1

b1: ← b0 # exit
	Return t3

# Name: command-line-arguments.f2
# Package: command-line-arguments
func f2[A any, B interface{~[]A}](_ A, _ B):
b0: # entry
	t1 = Parameter <A> {_}
	t2 = Parameter <B> {_}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: f2$generic#0
# Synthetic: generic
func f2$generic#0(_ byte, _ []byte):
b0: # entry
	t1 = Parameter <byte> {_}
	t2 = Parameter <[]byte> {_}
	t3 = ChangeType <A> t1
	t4 = ChangeType <B> t2
	t5 = Call <()> command-line-arguments.f2 byte []byte t3 t4
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.f2x
# Package: command-line-arguments
func f2x():
b0: # entry
	t1 = Const <byte> {0}
	t2 = HeapAlloc <*[0]byte>
	t3 = Slice <[]byte> t2 <nil> <nil> <nil>
	t4 = Call <()> f2$generic#0 t1 t3
	t5 = HeapAlloc <*[0]byte>
	t6 = Slice <[]byte> t5 <nil> <nil> <nil>
	t7 = Call <()> f2$generic#0 t1 t6
	t8 = HeapAlloc <*[0]byte>
	t9 = Slice <[]byte> t8 <nil> <nil> <nil>
	t10 = Call <()> f2$generic#0 t1 t9
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.f4
# Package: command-line-arguments
func f4[A any, B interface{~[]C}, C interface{~*A}](_ A, _ B, c C):
b0: # entry
	t1 = Parameter <A> {_}
	t2 = Parameter <B> {_}
	t3 = Parameter <C> {c}
	Jump → b1

b1: ← b0 # exit
	Return

# Name: f4$generic#0
# Synthetic: generic
func f4$generic#0(_ int, _ []*int, c *int):
b0: # entry
	t1 = Parameter <int> {_}
	t2 = Parameter <[]*int> {_}
	t3 = Parameter <*int> {c}
	t4 = ChangeType <A> t1
	t5 = ChangeType <B> t2
	t6 = ChangeType <C> t3
	t7 = Call <()> command-line-arguments.f4 int []*int *int t4 t5 t6
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.f4x
# Package: command-line-arguments
func f4x():
b0: # entry
	t1 = HeapAlloc <*int>
	t2 = Load <int> t1
	t3 = HeapAlloc <*[0]*int>
	t4 = Slice <[]*int> t3 <nil> <nil> <nil>
	t5 = Call <()> f4$generic#0 t2 t4 t1
	t6 = Load <int> t1
	t7 = HeapAlloc <*[0]*int>
	t8 = Slice <[]*int> t7 <nil> <nil> <nil>
	t9 = Call <()> f4$generic#0 t6 t8 t1
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.f5
# Package: command-line-arguments
func f5[A interface{~struct{b B; c C}}, B any, C interface{~*B}](x B) A:
b0: # entry
	t1 = Const <int> {0}
	t2 = AggregateConst <A> (GenericConst <B>, Const <C> {nil})
	t3 = Parameter <B> {x}
	t4 = MakeInterface <interface{}> t1
	Panic t4 → b1

b1: ← b0 # exit
	Return t2

# Name: f5$generic#0
# Synthetic: generic
func f5$generic#0(x float64) struct{b float64; c *float64}:
b0: # entry
	t1 = Parameter <float64> {x}
	t2 = ChangeType <B> t1
	t3 = Call <A> command-line-arguments.f5 struct{b float64; c *float64} float64 *float64 t2
	t4 = ChangeType <struct{b float64; c *float64}> t3
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: command-line-arguments.f5x
# Package: command-line-arguments
# Locals:
#   0:	t2 struct{b float64; c *float64}
func f5x():
b0: # entry
	t1 = Const <float64> {1.2}
	t2 = StackAlloc <*struct{b float64; c *float64}>
	t3 = Call <struct{b float64; c *float64}> f5$generic#0 t1
	Store {struct{b float64; c *float64}} t2 t3
	t5 = FieldAddr <*float64> [0] (b) t2
	t6 = Load <float64> t5
	BlankStore t6
	t8 = FieldAddr <**float64> [1] (c) t2
	t9 = Load <*float64> t8
	t10 = Load <float64> t9
	BlankStore t10
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.f6
# Package: command-line-arguments
func f6[A any, B interface{~struct{f []A}}](B) A:
b0: # entry
	t1 = Const <int> {0}
	t2 = GenericConst <A>
	t3 = Parameter <B> {arg0}
	t4 = MakeInterface <interface{}> t1
	Panic t4 → b1

b1: ← b0 # exit
	Return t2

# Name: f6$generic#0
# Synthetic: generic
func f6$generic#0(struct{f []string}) string:
b0: # entry
	t1 = Parameter <struct{f []string}> {arg0}
	t2 = ChangeType <B> t1
	t3 = Call <A> command-line-arguments.f6 string struct{f []string} t2
	t4 = ChangeType <string> t3
	Jump → b1

b1: ← b0 # exit
	Return t4

# Name: command-line-arguments.f6x
# Package: command-line-arguments
func f6x():
b0: # entry
	t1 = AggregateConst <struct{f []string}> (Const <[]string> {nil})
	t2 = Call <string> f6$generic#0 t1
	BlankStore t2
	Jump → b1

b1: ← b0 # exit
	Return

# Name: command-line-arguments.init
# Package: command-line-arguments
# Synthetic: package initializer
func init():
b0: # entry
	t1 = Const <bool> {true}
	t2 = Load <bool> init$guard
	If t2 → b1 b2

b1: ← b0 b2 # exit
	Return

b2: ← b0 # init.start
	Store {bool} init$guard t1
	Jump → b1
